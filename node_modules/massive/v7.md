ways projection is different from decomposition schemas:
- only special fields are `$key` and `columns`; no `decomposeTo` (define your nested quantity as an array or object)
- always maps except at the root? tbd
- articulation of nested quantities is now automatic with segments delimited by __
- columns must be aliased to the articulated path prefix to be visible (automatic with `join` or ordinary nested projections)
- _key_ columns must be prefixed with the path, although you can also use a child context (not recommended)

if a table yields its columns in iteration, can we `db.t1['column']` ? no that just gives us destructuring `...t1`
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols

db.t1.$column is legal....
but also object access ain't free in an interpreted language

aliasing(`db.table_name.as('t1')`): really have to commit the alias onto db (no reusability!) or use strings e.g. in `project()`

filtering before declaring the operation is kinda nice, huge departure tho
explicit entity caching implies a startup hook to prep your representations

only support named params in raw-ish filter expressions, indexed are too hard to juggle w/ reorderability

expr template-strings will render on function invocation.... https://github.com/graphile/graphile-engine/tree/master/packages/pg-sql2 ? adds a few more dependencies than i'd like.... or could rely on pg-promise's alternate delimiters $() etc

"can we overload limit" -> limit is actually nonstandard, we should generate a fetch clause (but limit is still well-known shorthand); `last` actually modifies the filter so that'll take some work

methods:
- join
- filter
- project
- group
- sort
- offset
- limit

```javascript
// how to avoid every entity having a handle on db or at minimum pgp:
// this also makes statements & partials reusable, and avoids db.blahblah(db)!!

db.select(db.mytbl.join(...).filter(...).project(...));
db.insert(db.mytbl.join(...), {...}, {...});
db.update(db.mytbl.join(...).filter(...), {...});
db.delete(db.mytbl.filter(...));

// can also manually cache
db.mytbl.join(...).project(...).cache('name');
db.select(db.name.filter(...));
db.select(db.mytbl.join(...).cache('name')); // throws? cache() probably shouldn't return a statement
```

```javascript
// regular
db.mytbl.select(db)

// withTransaction can still work
db.withTransaction(tx => {
  db.mytbl.select(tx);
  db.mytbl.filter(...).destroy({...});
});

// transaction; don't love error handling in client code
try {
  db.mytbl.select(tx)
  tx.commit();
} catch (e) {
  tx.rollback();
}

// yield query text
db.mytbl.select(db.asText)
```

```javascript
db.families
  .join(db.figures)
  .filter({ 'families.map_id': target }) // both tables have a map_id
  .project(
    db.families.$name,
    {
      total: db.agg.COUNT,
      all_names: db.agg.ARRAY_AGG(db.figures.$name),
      founding_year: db.expr(`date_part('year', families.founded_at)`),
      current_location_geojson: db.expr('st_asgeojson(f.current_location)::jsonb')
    }
  )
  .group(db.expr(`date_part('year', families.founded_at)`))
  .select();

db.revisions.join(db.models)
  .filter(
    { type: 'a type' },
    db.expr(`models.code || lpad(revisions.revision::text, 2, '0') = $(target)`, {target})
  )
  .project(
    db.revisions.$model_id,
    db.revisions.$revision
  ).select()

db.sites
  .filter(
    db.expr('st_distance(location, st_makepoint(${lon}, ${lat}, 4326), true) <= ${radius}', {
      lon: 12.34,
      lat: 56.78,
      radius: 100
    }),
    { is_active: true }
  ).select()

db.stations
  .filter({
    warehouse_id: id,
    'serial_number ilike': [1, 2, 3], // render sql `any`
    'blah &&': [4, 5, 6] // render array literal?
  })
  .project(db.stations.$station_id)
  .offset(5)
  .limit(10)
  .select()

db.users
  .lateral('role', db.expr('unnest(roles)'), {'role like': 'dev:%'})
  .filter({is_active: true})
  .project(
    db.users.$user_id,
    db.users.$display_name
  )
  .order(db.users.$display_name) // simplify if no direction
  .distinct()
  .select()

db.regions
  .project(
    db.regions.$country,
    db.regions.$country_code
  ).order({ // make this variadic
    field: db.regions.country,
    dir: db.dir.DESC
  })
  .distinct()
  .select()

db.union(
  db.inventory_items
    .join(db.inventory_counts)
    .filter({ 'inventory_counts.warehouse_id': id })
    .project(
      db.inventory_items.$inventory_item_id,
      {subassembly_version_id: null}, // have to declare name here
      db.inventory_items.$is_scannable,
      db.inventory_items.$name,
      {quantity: db.expr('coalesce(inventory_counts.quantity, 0)')}
    ),

  db.subassembly_type_versions.join(db.inventory_addon_counts)
    .filter({
      'subassembly_type_versions.addon_code <>': null,
      'inventory_addon_counts.warehouse_id': id
    })
    .project(
      null,
      'subassembly_type_versions.subassembly_version_id',
      false,
      'subassembly_type_versions.display_name',
      {quantity: db.expr('coalesce(subassembly_type_versions.quantity, 0)')}
    )
  )
  .order('name')
  .offset(5)
  .limit(10)
  .select()

// expose composite types? base types?
db.$types.myenum;

db.t1.only()
  .project(...)
  .select();

// keyset pagination
db.t1
  .filter({'price >': 10})
  .project(
    db.t1.$category,
    { monthly_sales: db.expr('annual_sales / 12') }
  )
  .sort({field: db.t1.category, nulls: db.nulls.LAST, last: 'widgets'})
  .pageLength(10) // can we overload limit() ?
  .select()

// reusable windows! or inline 'em
const win = db.window.partition(db.t1.$division).order(db.t1.$quantity);
db.t1
  .project(
    db.t1.$category,
    {
      rn: db.window.ROW_NUMBER(win),
      first: db.window.FIRST(db.t1.$name, win)
    }
  .select()

// cache and refresh
db.t1.join(db.t2).filter(...).cache('t1_2').select(....);
// LATER
db.t1_2.filter(MORE FILTERS).select(....);
db.t1_2.refresh(); // reload after schema changes
db.t1_2.remove(); // allow recaching, otherwise cache() will throw if t1_2 already exists

db.players
  .join(db.figures)
  .join(db.families, {family_id: db.figures.$family_id})
  .join(db.maps)
  .project(
    ...db.players,
    {
      figure: db.figures,
      family: db.families,
      map: db.maps
    }
  )
  .select()

db.family_stocks
  .join(db.resources)
  .join(db.resource_types)
  .join(db.adjustments, {
      family_id: db.family_stocks.$family_id,
      resource_id: db.resources.$resource_id
    },
    db.join.LEFT
  )
  .join(db.distributions, db.join.LEFT)
  .filter({
    family_id: player.family.family_id
  })
  .project(
    ...db.family_stocks,
    {
      resource: {
        $key: [db.resources.$resource_type_id, db.resources.$resource_id],
        ...db.resources.fields,
        type: db.resource_types.$type,
        typobj: {
          rtid: db.key(db.resource_types.$resource_type_id),
          type: db.resource_types.$type
        },
        typarr: [{
          rtid: db.key(db.resource_types.$resource_type_id),
          type: db.resource_types.$type
        }]
      },
      changes: [{
        ...db.adjustments.fields
      }]
    }

    {
      resource: {
        $key: [db.resources.ad_hoc_pk], // define an alternative or compound key
        ...db.resources, // destructures into 0: first, 1: second
        type: db.resource_types.$type,
        type_extra: {
          rtid: db.key(db.resource_types.$resource_type_id),
          type: db.resource_types.$type
        },
        type_arr: [
          db.key(db.resource_types.$resource_type_id),
          db.resource_types.$type
        ],
        type_arr_renamed: [
          db.key(db.resource_types.$resource_type_id), // this....
          {
            rtid: db.key(db.resource_types.$resource_type_id), // ....or db.key it
            type: db.resource_types.$type
          }
        ]
      },
      changes: [
        db.key(db.adjustments.$adjustment_id),
        ...db.adjustments, // destructures into first, second
        { distribution: db.distributions }
      ]
    }
  )
  .sort(
    db.resourcetype.$resource_type_id,
    db.resource.$name,
    { field: db.changes.$change, direction: db.dir.DESC }
  )
  .select()
```

```javascript
db.t1
  .join(db.t2)
  .join(db.t3, {id: db.t2.$t3_id, t1_id: db.t1.$id}, db.join.LEFT) // db.join is a symbol-enum
  ^^^^^ cache entity ^^^^^
  .filter({
    'val': 1 // fields still default to the root relation if not qualified
  });
  ^^^^^ cache entity? ^^^^^
  .project(
  // nest objects and arrays, limiting and renaming columns
    db.t1.$id,
    db.t2,
    {
      oneval_alias: db.t1.$val,
      teatwo_array: [
        db.t2.$id,
        {
          twoval_alias: db.t2.$val,
          teathree_array: [...db.t3],
          teathree_obj: {...db.t3}
        },
      ],
      teatwo_object: {
        id: db.t2.$id,
        {
          twoval_alias: db.t2.$val,
          teathree_array: [db.t3], // shorthand for array decomposition, all columns
          teathree_obj: db.t3 // shorthand for object decomposition, all columns
        }
      }
    }
  // omit t2 node
    db.t1.$id,
    {teathrees: [
    ...db.t3
    ]}
  // flatten
    ...db.t1,   // all columns in table
    't2.*',     // all columns in table, string specifier?
    db.t3.$val, // pick columns
    't3.val2'   // pick columns, stringwise?
  // default, toposorting fk graph
    ...db.t1,
    {
      t2: [
        ...db.t2,
        t3: [ ...db.t3 ]
      ]
    }
  ^^^^^ cache projection ^^^^^
  )
```

```javascript
db.select(
  db.mytbl.join(
    db.othertable.as('other'), // sets projection alias
    { id: db.mytbl.$other_id },
    db.join.INNER
  )
)
```

```javascript
db.figures.filter(
  {figure_id: id},
  [`array_position(tags, ${tag}) is null`]
).update({
  is_moving: false,
  tags: db.expr(`array_append(tags, ${tag})`)
})
```

```javascript
db.update(
  db.figures.filter(
    { [db.figures.$figure_id]: id },
    [`array_position(tags, ${tag}) is null`]
  )
  .set(db.figures.$is_moving, false)
  .set(db.figures.$tags, db.expr(`array_append(tags, ${tag})`))
);
```

```javascript
db.adjustments
  .join(db.families, {family_id: db.families.$family_id})
  .filter({'families.map_id': target})
  .destroy()
```









```javascript
// would be really cool, but probably impractical
db.query(`with blah as (select 123 as val) select a.*, blah.val from....`)
  .join(db.thisIsAQueryFile(params), {...})
  .join(db.this_is_a_table, {...})
  .find(...);
```

```javascript
db.table_name.as('t1')
  .join(db.other_table.as('t2'), {'t1.other_table_id': db.t2.columns.id})
  .filter({
    't2.category': 'target'
  })
  .select() // automatic projection with aliased names
```
